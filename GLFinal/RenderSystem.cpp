#include "RenderSystem.hpp"
#include "FPSCamera.hpp"
#include "Globals.hpp"
#include "Window.hpp"
#include <GLM/glm.hpp>
#include <GLM/gtc/matrix_transform.hpp>
#include <GlM/gtc/type_ptr.hpp>

namespace Saturn::Systems {

void RenderSystem::onStart() {
    glEnable(GL_DEPTH_TEST);
    defaultShader = Shader(defaultVertexPath, defaultFragmentPath);
    texturedShader = Shader(texturedVertexPath, texturedFragmentPath);
}

void RenderSystem::onUpdate() {
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    for (auto ptr : getObjects<Components>()) {
        // Get a reference for simplicity
        auto& obj = *ptr;
        auto& transform = obj.getComponent<Transform>();
        auto& model = obj.getComponent<Mesh>().model;

        // Get active shader, this is defaulted to the default shader, but can
        // be set to other shaders if for example a Material component is
        // attached to the object
        Shader* active = &defaultShader;

        // Activate the shader
        active->use();

		//#TODO: Support for multiple textures in renderer

        // Temporary shader
        if (obj.hasComponent<Material>()) {
            active = &texturedShader;
            active->use();
            // Set the material properties
            auto& mat = obj.getComponent<Material>();
            glUniform1i(active->location("tex"),
                        mat.texture->unit - GL_TEXTURE0);
            glActiveTexture(mat.texture->unit);
            glBindTexture(GL_TEXTURE_2D, mat.texture->handle);
        }

        // Generate MVP matrices

        // Generate model matrix from Transform component. Note that the order
        // does not matter for translation, rotation and scaling

        active->model = glm::translate(active->model, transform.position);
        active->model = glm::rotate(active->model, transform.rotation.angle,
                                    transform.rotation.axis);

        active->model = glm::scale(active->model, transform.scale);

        // The view matrix is generated by the camera:
        active->view = gCamera->view_matrix();

        // The projection matrix depends on the camera's Zoom and on the screen
        active->projection = glm::perspective(
            glm::radians(gCamera->Zoom),
            (float)gWindow->width() / gWindow->height(), 0.1f, 100.0f);

        // Send data to shader
        active->update_uniforms();

        // Render the object
        glBindVertexArray(model->vao);
        glDrawArrays(GL_TRIANGLES, 0, model->vertex_count);
        glBindTexture(GL_TEXTURE_2D, 0);
        glBindVertexArray(0);
    }
}

} // namespace Saturn::Systems
