#include "RenderSystem.hpp"
#include "FPSCamera.hpp"
#include "Globals.hpp"
#include "Window.hpp"
#include <GLM/glm.hpp>
#include <GLM/gtc/matrix_transform.hpp>
#include <GlM/gtc/type_ptr.hpp>

namespace Saturn::Systems {

void RenderSystem::onStart() {
    glEnable(GL_DEPTH_TEST);
    defaultShader = Shader(defaultVertexPath, defaultFragmentPath);
}

void RenderSystem::onUpdate() {
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    for (auto ptr : getObjects<Components>()) {
        // Get a reference for simplicity
        auto& obj = *ptr;
        auto& transform = obj.getComponent<Transform>();
        auto& model = obj.getComponent<Mesh>().model;

        // Generate MVP matrices

        // Generate model matrix from Transform component. Note that the order
        // does not matter for translation, rotation and scaling
        defaultShader.model =
            glm::translate(defaultShader.model, transform.position);
        defaultShader.model =
            glm::rotate(defaultShader.model, transform.rotation.angle,
                        transform.rotation.axis);

        defaultShader.model = glm::scale(defaultShader.model, transform.scale);

        // The view matrix is generated by the camera:
        defaultShader.view = gCamera->view_matrix();

        // The projection matrix depends on the camera's Zoom and on the screen
        defaultShader.projection = glm::perspective(
            glm::radians(gCamera->Zoom),
            (float)gWindow->width() / gWindow->height(), 0.1f, 100.0f);

        // Activate shader and set the data to it
        defaultShader.use();
        defaultShader.update_uniforms();

        // Render the object
        glBindVertexArray(model->vao);
        glDrawArrays(GL_TRIANGLES, 0, model->vertex_count);
    }
}

} // namespace Saturn::Systems
