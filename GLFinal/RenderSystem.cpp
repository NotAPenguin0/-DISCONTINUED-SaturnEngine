#include "RenderSystem.hpp"
#include "Application.hpp"
#include "FPSCamera.hpp"
#include "Globals.hpp"
#include "Utility.hpp"
#include "Window.hpp"
#include <GLM/glm.hpp>
#include <GLM/gtc/matrix_transform.hpp>
#include <GlM/gtc/type_ptr.hpp>
#include <functional>

namespace Saturn::Systems {

void RenderSystem::onStart() {
    glEnable(GL_DEPTH_TEST);
    // Load ligthShader (which is the default)
    lightShader = gApp->getResourceManager<Resources::Shader>().get(
        "resources/shaders/light.sh");
}

void RenderSystem::onUpdate() {
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    Components::Shader tempShaderComponent;
    tempShaderComponent.shader = lightShader;
    setupLightingUniforms(tempShaderComponent);

    for (auto ptr : getObjects<RenderComponents>()) {
        // Get a reference for simplicity
        auto& obj = *ptr;
        auto& transform = obj.getComponent<Transform>();
        auto& model = obj.getComponent<Mesh>().model;
        auto& shader = obj.getComponent<Shader>();
        auto& material = obj.getComponent<Material>();
		
		//If the shader is lit, use the lighting shader instead
        if (shader.lit) {
            glUseProgram(lightShader->handle);
        } else {
            // Activate the shader
            glUseProgram(shader.shader->handle);
        }

        // Generate MVP matrices

        glm::mat4 mod = glm::mat4(1.0);
        glm::mat4 view = glm::mat4(1.0);
        glm::mat4 proj = glm::mat4(1.0);

        // Generate model matrix from Transform component. Note that the order
        // does not matter for translation, rotation and scaling

        mod = glm::translate(mod, transform.position);
        mod =
            glm::rotate(mod, transform.rotation.angle, transform.rotation.axis);

        mod = glm::scale(mod, transform.scale);

        // The view matrix is generated by the camera:
        view = gCamera->view_matrix();

        // The projection matrix depends on the camera's Zoom and on the screen
        proj = glm::perspective(glm::radians(gCamera->Zoom),
                                (float)gWindow->width() / gWindow->height(),
                                0.1f, 100.0f);

        // If it has a texture. When using lighting you should set textures
        // using the diffuse map instead
        if (material.texture != null_resource) {
            // Check if it has the correct texture unit
            if (material.texture->unit != MainTextureUnit) {
                Saturn::warning(
                    "Trying to draw texture with unit " +
                    std::to_string(material.texture->unit) +
                    ". Expected unit: " + std::to_string(MainTextureUnit));
            }
            glActiveTexture(MainTextureUnit + GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.texture->handle);
            glUniform1i(glGetUniformLocation(shader.shader->handle, "tex"),
                        MainTextureUnit);
        }

        // Material
        if (material.lighting.diffuseMap != null_resource &&
            material.lighting.specularMap != null_resource) {

            // Check if the texture units are correct
            if (material.lighting.diffuseMap->unit != DiffuseMapTextureUnit) {
                Saturn::warning(
                    "Trying to draw texture with unit " +
                    std::to_string(material.lighting.diffuseMap->unit) +
                    ". Expected unit: " +
                    std::to_string(DiffuseMapTextureUnit));
            }
            if (material.lighting.specularMap->unit != SpecularMapTextureUnit) {
                Saturn::warning(
                    "Trying to draw texture with unit " +
                    std::to_string(material.lighting.specularMap->unit) +
                    ". Expected unit: " +
                    std::to_string(SpecularMapTextureUnit));
            }

            // Bind textures

            // Diffuse
            glActiveTexture(DiffuseMapTextureUnit + GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.lighting.diffuseMap->handle);
            // Specular
            glActiveTexture(SpecularMapTextureUnit + GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.lighting.specularMap->handle);

            // Set material uniform values

            // Ambient
            glUniform3fv(location(shader, "material.ambient"), 1,
                         glm::value_ptr(material.lighting.ambient));
            // Diffuse
            glUniform1i(location(shader, "material.diffuse"),
                        DiffuseMapTextureUnit + GL_TEXTURE0);
            // Specular
            glUniform1i(location(shader, "material.specular"),
                        SpecularMapTextureUnit + GL_TEXTURE0);

            // Shininess
            glUniform1f(location(shader, "material.shininess"),
                        material.lighting.shininess);
        }

        setShaderUniforms(shader, mod, view, proj);

        // Render the object
        glBindVertexArray(model->vao);
        glDrawArrays(GL_TRIANGLES, 0, model->vertex_count);
        glBindVertexArray(0);
        glActiveTexture(DiffuseMapTextureUnit + GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, 0);
        glActiveTexture(SpecularMapTextureUnit + GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, 0);
        glActiveTexture(MainTextureUnit + GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, 0);
    }
}

void RenderSystem::directionalUniforms(
    Components::Shader& shader, std::vector<DirectionalLight*> const& lights) {

    glUniform1i(location(shader, "directional_size"), lights.size());
    // Loop over directional lights, set their uniforms
    for (std::size_t i = 0; i < lights.size(); ++i) {
        auto str = std::to_string(i);
        static std::string arr_name = "directional"
                                      "[";
        auto full_name = arr_name + str + "].";

        auto const& light = *lights[i];

        auto dir = location(shader, full_name + "direction");
        auto amb = location(shader, full_name + "ambient");
        auto diff = location(shader, full_name + "diffuse");
        auto spec = location(shader, full_name + "specular");

        // Set direction, diffuse, ambient and specular values
        glUniform3fv(dir, 1, glm::value_ptr(light.direction));
        glUniform3fv(amb, 1, glm::value_ptr(light.ambient));
        glUniform3fv(diff, 1, glm::value_ptr(light.diffuse));
        glUniform3fv(spec, 1, glm::value_ptr(light.specular));
    }
}

void RenderSystem::pointUniforms(Components::Shader& shader,
                                 std::vector<PointLight*> const& lights) {
    glUniform1i(location(shader, "point_size"), lights.size());

    for (std::size_t i = 0; i < lights.size(); ++i) {
        auto str = std::to_string(i);
        static std::string arr_name = "point[";
        auto full_name = arr_name + str + "].";

        auto const& light = *lights[i];

        // Set direction, ambient, diffuse and specular values
        glUniform3fv(location(shader, full_name + "position"), 1,
                     glm::value_ptr(light.position));
        glUniform3fv(location(shader, full_name + "ambient"), 1,
                     glm::value_ptr(light.ambient));
        glUniform3fv(location(shader, full_name + "diffuse"), 1,
                     glm::value_ptr(light.diffuse));
        glUniform3fv(location(shader, full_name + "specular"), 1,
                     glm::value_ptr(light.specular));
        // Set attenuation factors
        glUniform1f(location(shader, full_name + "constant"), light.constant);
        glUniform1f(location(shader, full_name + "linear"), light.linear);
        glUniform1f(location(shader, full_name + "quadratic"), light.quadratic);
    }
}

void RenderSystem::spotUniforms(Components::Shader& shader,
                                std::vector<SpotLight*> const& lights) {
    glUniform1i(location(shader, "spot_size"), lights.size());
    for (std::size_t i = 0; i < lights.size(); ++i) {
        auto str = std::to_string(i);
        static std::string arr_name = "spot[";
        auto full_name = arr_name + str + "].";

        auto const& light = *lights[i];

        // Set direction, ambient, diffuse and specular values
        glUniform3fv(location(shader, full_name + "position"), 1,
                     glm::value_ptr(light.position));
        glUniform3fv(location(shader, full_name + "direction"), 1,
                     glm::value_ptr(light.direction));
        glUniform3fv(location(shader, full_name + "ambient"), 1,
                     glm::value_ptr(light.ambient));
        glUniform3fv(location(shader, full_name + "diffuse"), 1,
                     glm::value_ptr(light.diffuse));
        glUniform3fv(location(shader, full_name + "specular"), 1,
                     glm::value_ptr(light.specular));
        // Set attenuation factors
        glUniform1f(location(shader, full_name + "constant"), light.constant);
        glUniform1f(location(shader, full_name + "linear"), light.linear);
        glUniform1f(location(shader, full_name + "quadratic"), light.quadratic);
        glUniform1f(location(shader, full_name + "cutOff"),
                    glm::cos(light.radius));
        glUniform1f(location(shader, full_name + "outerCutOff"),
                    glm::cos(light.soft_radius));
    }
} // namespace Saturn::Systems

void RenderSystem::setupLightingUniforms(Components::Shader& shader) {
	//Make sure the shader is in use so we can set the uniforms
    glUseProgram(shader.shader->handle);
    std::vector<DirectionalLight*> dirLights;
    std::vector<PointLight*> ptLights;
    std::vector<SpotLight*> sptLights;

    for (auto lamp : getObjects<ListComponents<Lights>>()) {
        auto& lights = lamp->getComponent<Lights>();
        auto& dir = lights.directionalLights;
        auto& point = lights.pointLights;
        auto& spot = lights.spotLights;
        merge(to_pointers(dir), dirLights);
        merge(to_pointers(spot), sptLights);
        merge(to_pointers(point), ptLights);
    }

    // Set light uniforms
    directionalUniforms(shader, dirLights);
    pointUniforms(shader, ptLights);
    spotUniforms(shader, sptLights);

    // Set viewing position
    glUniform3fv(location(shader, "viewPos"), 1,
                 glm::value_ptr(gCamera->Position));
}

void RenderSystem::setShaderUniforms(Components::Shader& shader,
                                     glm::mat4 const& model,
                                     glm::mat4 const& view,
                                     glm::mat4 const& projection) {

    auto handle = shader.shader->handle;
    glUniformMatrix4fv(glGetUniformLocation(handle, "model"), 1, GL_FALSE,
                       glm::value_ptr(model));
    glUniformMatrix4fv(glGetUniformLocation(handle, "view"), 1, GL_FALSE,
                       glm::value_ptr(view));
    glUniformMatrix4fv(glGetUniformLocation(handle, "projection"), 1, GL_FALSE,
                       glm::value_ptr(projection));
}

int RenderSystem::location(Components::Shader& shader, std::string name) {
    auto loc = glGetUniformLocation(shader.shader->handle, name.c_str());
    if (loc == -1) Saturn::warning("Failed to find uniform with name: " + name);
    return loc;
}

} // namespace Saturn::Systems
