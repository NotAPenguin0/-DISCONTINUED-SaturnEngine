#include "RenderSystem.hpp"
#include "FPSCamera.hpp"
#include "Globals.hpp"
#include "Window.hpp"
#include <GLM/glm.hpp>
#include <GLM/gtc/matrix_transform.hpp>
#include <GlM/gtc/type_ptr.hpp>

namespace Saturn::Systems {

void RenderSystem::onStart() { glEnable(GL_DEPTH_TEST); }

void RenderSystem::onUpdate() {
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	for (auto ptr : getObjects<RenderComponents>()) {
        // Get a reference for simplicity
        auto& obj = *ptr;
        auto& transform = obj.getComponent<Transform>();
        auto& model = obj.getComponent<Mesh>().model;
        auto& shader = obj.getComponent<Shader>();

        // Activate the shader
        glUseProgram(shader.shader->handle);

        // Generate MVP matrices

        // Generate model matrix from Transform component. Note that the order
        // does not matter for translation, rotation and scaling

        glm::mat4 mod = glm::mat4(1.0);
        glm::mat4 view = glm::mat4(1.0);
        glm::mat4 proj = glm::mat4(1.0);

        mod = glm::translate(mod, transform.position);
        mod =
            glm::rotate(mod, transform.rotation.angle, transform.rotation.axis);

        mod = glm::scale(mod, transform.scale);

        // The view matrix is generated by the camera:
        view = gCamera->view_matrix();

        // The projection matrix depends on the camera's Zoom and on the screen
        proj = glm::perspective(glm::radians(gCamera->Zoom),
                                (float)gWindow->width() / gWindow->height(),
                                0.1f, 100.0f);

        setShaderUniforms(shader, mod, view, proj);

        // Render the object
        glBindVertexArray(model->vao);
        glDrawArrays(GL_TRIANGLES, 0, model->vertex_count);
        glBindVertexArray(0);
    }
}

void RenderSystem::setShaderUniforms(Components::Shader& shader,
	glm::mat4 const& model,
	glm::mat4 const& view,
	glm::mat4 const& projection) {

	auto handle = shader.shader->handle;
	glUniformMatrix4fv(glGetUniformLocation(handle, "model"), 1, GL_FALSE, glm::value_ptr(model));
    glUniformMatrix4fv(glGetUniformLocation(handle, "view"), 1, GL_FALSE,
                       glm::value_ptr(view));
    glUniformMatrix4fv(glGetUniformLocation(handle, "projection"), 1, GL_FALSE,
                       glm::value_ptr(projection));

}

} // namespace Saturn::Systems
